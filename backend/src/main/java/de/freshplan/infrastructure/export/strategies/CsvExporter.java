package de.freshplan.infrastructure.export.strategies;

import de.freshplan.infrastructure.export.*;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.ws.rs.core.StreamingOutput;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;
import org.jboss.logging.Logger;

/**
 * CSV export strategy implementation.
 * Generates CSV files with proper escaping and UTF-8 BOM for Excel compatibility.
 * 
 * @author FreshPlan Team
 * @since 2.0.0
 */
@ApplicationScoped
public class CsvExporter implements ExportStrategy {
    
    private static final Logger log = Logger.getLogger(CsvExporter.class);
    private static final String DELIMITER = ",";
    private static final String QUOTE = "\"";
    private static final String LINE_BREAK = "\n";
    
    @Override
    public ExportFormat getFormat() {
        return ExportFormat.CSV;
    }
    
    @Override
    public ExportResult export(List<?> data, ExportConfig config) {
        log.infof("Exporting %d records to CSV", data.size());
        
        // Create streaming output for efficient memory usage
        StreamingOutput stream = output -> {
            try (BufferedWriter writer = new BufferedWriter(
                    new OutputStreamWriter(output, StandardCharsets.UTF_8))) {
                
                // Write UTF-8 BOM for Excel compatibility
                writer.write('\ufeff');
                
                // Write metadata as comments if configured
                if (config.getFormatOptions().getOrDefault("includeMetadata", false).equals(true)) {
                    try {
                        writeMetadata(writer, config);
                    } catch (Exception e) {
                        throw new RuntimeException("Failed to write metadata", e);
                    }
                }
                
                // Write header row
                try {
                    writeHeader(writer, config.getVisibleFields());
                } catch (Exception e) {
                    throw new RuntimeException("Failed to write header", e);
                }
                
                // Write data rows
                for (Object record : data) {
                    try {
                        writeDataRow(writer, record, config.getVisibleFields());
                    } catch (Exception e) {
                        throw new RuntimeException("Failed to write data row", e);
                    }
                }
                
                writer.flush();
            }
        };
        
        // Generate filename
        String filename = generateFilename(config);
        
        return ExportResult.builder()
            .format(ExportFormat.CSV)
            .filename(filename)
            .recordCount(data.size())
            .withStreamData(stream)
            .addMetadata("delimiter", DELIMITER)
            .addMetadata("encoding", "UTF-8 with BOM")
            .addMetadata("fieldCount", config.getVisibleFields().size())
            .build();
    }
    
    /**
     * Write metadata as CSV comments
     */
    private void writeMetadata(BufferedWriter writer, ExportConfig config) throws Exception {
        if (config.getTitle() != null) {
            writer.write("# " + config.getTitle());
            writer.write(LINE_BREAK);
        }
        if (config.getSubtitle() != null) {
            writer.write("# " + config.getSubtitle());
            writer.write(LINE_BREAK);
        }
        writer.write("# Generated: " + LocalDateTime.now().format(
            DateTimeFormatter.ofPattern("dd.MM.yyyy HH:mm:ss")));
        writer.write(LINE_BREAK);
        if (config.getGeneratedBy() != null) {
            writer.write("# Generated by: " + config.getGeneratedBy());
            writer.write(LINE_BREAK);
        }
        writer.write("# ");
        writer.write(LINE_BREAK);
    }
    
    /**
     * Write CSV header row
     */
    private void writeHeader(BufferedWriter writer, List<ExportConfig.FieldConfig> fields) 
            throws Exception {
        boolean first = true;
        for (ExportConfig.FieldConfig field : fields) {
            if (!first) {
                writer.write(DELIMITER);
            }
            writer.write(escapeValue(field.getLabel()));
            first = false;
        }
        writer.write(LINE_BREAK);
    }
    
    /**
     * Write a data row
     */
    private void writeDataRow(BufferedWriter writer, Object record, 
            List<ExportConfig.FieldConfig> fields) throws Exception {
        boolean first = true;
        for (ExportConfig.FieldConfig field : fields) {
            if (!first) {
                writer.write(DELIMITER);
            }
            
            Object value = extractFieldValue(record, field.getKey());
            String formatted = formatFieldValue(value, field);
            writer.write(escapeValue(formatted));
            
            first = false;
        }
        writer.write(LINE_BREAK);
    }
    
    /**
     * Escape CSV value according to RFC 4180
     */
    private String escapeValue(String value) {
        if (value == null) {
            return "";
        }
        
        // Check if escaping is needed
        boolean needsEscaping = value.contains(DELIMITER) || 
                               value.contains(QUOTE) || 
                               value.contains("\n") || 
                               value.contains("\r");
        
        if (!needsEscaping) {
            return value;
        }
        
        // Escape by wrapping in quotes and doubling internal quotes
        return QUOTE + value.replace(QUOTE, QUOTE + QUOTE) + QUOTE;
    }
    
    /**
     * Generate filename for CSV export
     */
    private String generateFilename(ExportConfig config) {
        String base = config.getTitle() != null ? 
            config.getTitle().toLowerCase()
                .replaceAll("[^a-z0-9]+", "_")
                .replaceAll("_+", "_")
                .replaceAll("^_|_$", "") : 
            "export";
        
        String timestamp = LocalDateTime.now().format(
            DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss"));
        
        return base + "_" + timestamp;
    }
    
    @Override
    public String formatDate(Object value, String pattern) {
        if (value instanceof LocalDateTime dateTime) {
            String format = pattern != null ? pattern : "dd.MM.yyyy";
            return dateTime.format(DateTimeFormatter.ofPattern(format));
        }
        return value.toString();
    }
    
    @Override
    public String formatDateTime(Object value, String pattern) {
        if (value instanceof LocalDateTime dateTime) {
            String format = pattern != null ? pattern : "dd.MM.yyyy HH:mm:ss";
            return dateTime.format(DateTimeFormatter.ofPattern(format));
        }
        return value.toString();
    }
    
    @Override
    public String formatCurrency(Object value, String currency) {
        if (value instanceof Number number) {
            String curr = currency != null ? currency : "EUR";
            return String.format("%.2f %s", number.doubleValue(), curr);
        }
        return value.toString();
    }
    
    @Override
    public String formatPercentage(Object value) {
        if (value instanceof Number number) {
            return String.format("%.1f%%", number.doubleValue() * 100);
        }
        return value.toString();
    }
    
    @Override
    public String formatNumber(Object value, String pattern) {
        if (value instanceof Number number) {
            if (pattern != null && pattern.contains(".")) {
                int decimals = pattern.length() - pattern.indexOf(".") - 1;
                return String.format("%." + decimals + "f", number.doubleValue());
            }
            return number.toString();
        }
        return value.toString();
    }
}