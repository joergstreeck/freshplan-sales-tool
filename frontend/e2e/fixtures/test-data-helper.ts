/**
 * E2E Test Data Helper
 *
 * Creates and cleans up test data for E2E tests.
 * Each test run creates its own isolated test customers with timeline/contacts data.
 *
 * @module E2E/Fixtures/TestDataHelper
 * @since Sprint 2.1.7.2
 */

import { request, APIRequestContext } from '@playwright/test';

export interface TestCustomer {
  id: string;
  companyName: string;
  customerNumber: string;
}

interface TestDataContext {
  customers: TestCustomer[];
  apiContext: APIRequestContext;
}

let testDataContext: TestDataContext | null = null;

/**
 * Creates test customers with timeline activities and contacts
 * Called in beforeAll() hook
 */
export async function setupTestData(_baseURL: string): Promise<TestDataContext> {
  // Always use backend URL for API requests (not frontend URL)
  const backendURL = 'http://localhost:8080';

  const apiContext = await request.newContext({
    baseURL: backendURL,
    extraHTTPHeaders: {
      'Content-Type': 'application/json',
    },
  });

  const customers: TestCustomer[] = [];

  // Create 3 test customers with different data scenarios
  // Note: customerNumber is auto-generated by backend, not set here
  const testCustomers = [
    {
      companyName: '[E2E-TEST] FreshEvents Catering AG',
      hasTimeline: true,
      hasContacts: true,
    },
    {
      companyName: '[E2E-TEST] Großhandel Frische Küche',
      hasTimeline: true,
      hasContacts: true,
    },
    {
      companyName: '[E2E-TEST] Restaurant Silbertanne München',
      hasTimeline: false, // Empty state test
      hasContacts: false, // Empty state test
    },
  ];

  for (const testCustomer of testCustomers) {
    try {
      // 1. Create Customer (with all required fields)
      const customerResponse = await apiContext.post('/api/customers', {
        data: {
          companyName: testCustomer.companyName,
          customerType: 'UNTERNEHMEN', // Required: CustomerType enum (NEUKUNDE, UNTERNEHMEN, INSTITUTION, PRIVAT, VEREIN, SONSTIGE)
          businessType: 'CATERING', // Optional: BusinessType enum (replaces deprecated 'industry')
          status: 'AKTIV', // Optional: CustomerStatus enum (LEAD, PROSPECT, AKTIV, RISIKO, INAKTIV, ARCHIVIERT)
          classification: 'B_KUNDE', // Optional: Customer classification
        },
      });

      if (!customerResponse.ok()) {
        console.error(`Failed to create customer ${testCustomer.companyName}:`, await customerResponse.text());
        continue;
      }

      const customer = await customerResponse.json();
      customers.push({
        id: customer.id,
        companyName: customer.companyName,
        customerNumber: customer.customerNumber,
      });

      // 2. Create Timeline Activities (if specified)
      if (testCustomer.hasTimeline) {
        const activities = [
          {
            activityType: 'EMAIL',
            activityDate: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString(),
            description: 'Angebot versendet',
            userId: 'e2e-test-user',
          },
          {
            activityType: 'CALL',
            activityDate: new Date(Date.now() - 5 * 24 * 60 * 60 * 1000).toISOString(),
            description: 'Telefonat geführt',
            userId: 'e2e-test-user',
          },
          {
            activityType: 'MEETING',
            activityDate: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString(),
            description: 'Besuch vor Ort',
            userId: 'e2e-test-user',
          },
        ];

        for (const activity of activities) {
          await apiContext.post(`/api/customers/${customer.id}/timeline`, {
            data: activity,
          });
        }
      }

      // 3. Create Contacts (if specified)
      if (testCustomer.hasContacts) {
        const contacts = [
          {
            firstName: 'Max',
            lastName: 'Mustermann',
            email: 'max.mustermann@example.com',
            phone: '+49 123 456789',
            isPrimary: true,
            isActive: true,
            decisionLevel: 'entscheider',
            relationshipWarmth: 85,
          },
          {
            firstName: 'Anna',
            lastName: 'Schmidt',
            email: 'anna.schmidt@example.com',
            phone: '+49 987 654321',
            isPrimary: false,
            isActive: true,
            decisionLevel: 'mitentscheider',
            relationshipWarmth: 70,
          },
        ];

        for (const contact of contacts) {
          await apiContext.post(`/api/customers/${customer.id}/contacts`, {
            data: contact,
          });
        }
      }

      console.log(`✅ Created test customer: ${testCustomer.companyName} (${customer.id})`);
    } catch (error) {
      console.error(`Failed to setup test customer ${testCustomer.companyName}:`, error);
    }
  }

  testDataContext = { customers, apiContext };
  return testDataContext;
}

/**
 * Cleans up all test data created during the test run
 * Called in afterAll() hook
 */
export async function cleanupTestData(): Promise<void> {
  if (!testDataContext) {
    console.log('No test data to cleanup');
    return;
  }

  const { customers, apiContext } = testDataContext;

  // Delete all test customers (cascade will delete timeline/contacts)
  for (const customer of customers) {
    try {
      const response = await apiContext.delete(`/api/customers/${customer.id}`);
      if (response.ok()) {
        console.log(`✅ Deleted test customer: ${customer.companyName}`);
      } else {
        console.error(`Failed to delete customer ${customer.companyName}:`, await response.text());
      }
    } catch (error) {
      console.error(`Error deleting customer ${customer.companyName}:`, error);
    }
  }

  await apiContext.dispose();
  testDataContext = null;
}

/**
 * Gets test customers created during setup
 * Use this in tests to find specific test customers
 */
export function getTestCustomers(): TestCustomer[] {
  return testDataContext?.customers || [];
}

/**
 * Finds test customer by name pattern
 */
export function findTestCustomer(namePattern: string): TestCustomer | undefined {
  return getTestCustomers().find(c => c.companyName.includes(namePattern));
}
